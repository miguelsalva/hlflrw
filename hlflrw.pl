#!/usr/bin/perl
#
# [HLFLRW / HLFL Rules Writer]
# Miguel Salva
#
# "HLFL stands for High Level Firewall Language. It permits writing
# firewalling rules using a high level language, and transforms them into
# rules for real softwares" from the HLFL README file.
#
# HLFLRW sets a HLFL rules file asking a few questions, and then transforming
# them into the software (ipfw, ipfilter, ipfdadm, ipchains, iptables and
# cisco acl supported) you need.
#
# You need HLFL installed and root level on your system for the
# transforming support. Get HLFL from http://www.hlfl.org
#


print "\n\n **************************\n";
print " HLFLRW / HLFL Rules Writer\n";
print "               Miguel Salva\n";
print " **************************\n\n";
open (f,">rules.hlfl");
print f "%\n";
print f "% Rules generated by HLFLRW / HLFL Rules Writer\n";
print f "%                                  Miguel Salva\n";
print f "%\n";
print f "\n";
print "** We accept all traffic from the localhost device\n\n";
print f "all (any) <-> (any) [lo]\n\n";
print "** Do you want to set your ethernet device up? [y/n]: ";
$ans1= <STDIN>; chop($ans1);
if ($ans1 eq "y") {
  print "- Set the name of your ethernet device: ";
  $eth= <STDIN>; chop($eth);
  print "- We accept all TCP output traffic from $eth\n";
  print f "tcp (any) -> (any) [$eth]\n";
  print "- Do you want to accept all traffic from ethernet device? [y/n]: ";
  $ans2= <STDIN>; chop($ans2);
  if ($ans2 eq "y") {
    print f "all (any) <-> (any) [$eth]\n";
    }
  else {
    print "- All conections are DENIED by default\n";
    print "- Set the port you want to keep opened: ";
    $port= <STDIN>; chop($port);
    print "- Which protocol (tcp/udp)? [if you dont know write tcp]: ";
    $proto= <STDIN>; chop($proto);
    print f "$proto (any $port) <- (any) [$eth]\n";
    print "- Do you want to keep another port opened? [y/n]: ";
    $ans3= <STDIN>; chop($ans3);
    while ($ans3 eq "y") {
      print "- Set the port you want to keep opened: ";
      $port= <STDIN>; chop($port);
      print "- Which protocol (tcp/udp)? [if you dont know write tcp]: ";
      $proto= <STDIN>; chop($proto);
      print f "$proto (any $port) <- (any) [$eth]\n";
      print "- Do you want to keep another port opened: ";
      $ans3= <STDIN>; chop($ans3);
      }
    }
  }

print f "\n";
print "\n";
print "** Do you want to set your ppp conection up? [y/n]: ";
$ans4= <STDIN>; chop($ans4);
if ($ans4 eq "y") {
  print "- Set the name of your ppp device: ";
  $ppp= <STDIN>; chop($ppp);
  print "- We accept all TCP output traffic from $ppp\n";
  print f "tcp (any) -> (any) [$ppp]\n";
  print "- Do you want to accept all traffic from ppp device? [y/n]: ";
  $ans5= <STDIN>; chop($ans5);
  if ($ans5 eq "y") {
    print f "all (any) <-> (any) [$ppp]\n";
    }
  else {
    print "- All conections are DENIED by default\n";
    print "- Set the port you want to keep opened: ";
    $port= <STDIN>; chop($port);
    print "- Which protocol (tcp/udp)? [if you dont know write tcp]: ";
    $proto= <STDIN>; chop($proto);
    print f "$proto (any $port) <- (any) [$ppp]\n";
    print "- Do you want to keep another port opened? [y/n]: ";
    $ans6= <STDIN>; chop($ans6);
    while ($ans6 eq "y") {
      print "- Set the port you want to keep opened: ";
      $port= <STDIN>; chop($port);
      print "- Which protocol (tcp/udp)? [if you dont know write tcp]: ";
      $proto= <STDIN>; chop($proto);
      print f "$proto (any $port) <- (any) [$ppp]\n";
      print "-Do you want to keep another port opened? [y/n]: ";
      $ans6= <STDIN>; chop($ans6);
      }
    }
  }

print f "\n";
print "\n";
print "** Do you want a working ping? [y/n]: ";
$ping= <STDIN>; chop($ping);
if ($ping eq "y") {
  print f "icmp (any echo-request) -> (any)\n";
  print f "icmp (any) <- (any echo-reply)\n";
  }
close(f);

print "\n ** You have your rules at rules.hlfl\n";
print " ** That file is written in HLFL\n";
print " - Do you want to transform that file into real firewall\n";
print "   rules? [y/n]  /HLFL installed and root level needed/: ";
$trans= <STDIN>; chop($trans);
print "\n";
if ($trans eq "y") {
  $user= `id -g`;
  if ($user == 0) {
    print " ** What type of rules do you want to transform rules.hlfl in?\n";
    print " Firewall rules supported:\n";
    print "(1). ipfw                / FreeBSD\n";
    print "(2). ipfilter            / NetBSD\n";
    print "(3). ipfwadm             / Linux kernel 2.0.x\n";
    print "(4). ipchains            / Linux kernel 2.2.x\n";
    print "(5). netfilter/iptables  / Linux kernel 2.4.x\n";
    print "(6). Cisco ACL           / Cisco Routers and PIX\n\n";
    print "Choose an option: ";
    $rule= <STDIN>; chop($rule);
    print "\n";

    # PERL doesnt implement switch structures in its core ...
    # -- CRAPPY CODE STARTS --
    if ($rule==1) {
      system('hlfl ipfw <rules.hlfl> rules.real');
      }
    elsif ($rule==2) {
      system('hlfl ipfilter <rules.hlfl> rules.real');
      }
    elsif ($rule==3) {
      system('hlfl ipfwadm <rules.hlfl> rules.real');
      }
    elsif ($rule==4) {
      system('hlfl ipchains <rules.hlfl> rules.real');
      }
    elsif ($rule==5) {
      system('hlfl netfilter <rules.hlfl> rules.real');
      }
    elsif ($rule==6) {
      system('hlfl cisco <rules.hlfl> rules.real');
      }
    else {
      print "Incorrect option";
      exit;
      }
    # -- CRAPPY CODE ENDS -- ;)

    system('chmod +x rules.real');
    print " ** You have your rules at rules.real\n\n";
    }
  else {
    print " ** The HLFL rules have been generated, but you\n";
    print "    must be root to transform it into real software rules\n";
    print " ** The HLFL rules file is rules.hlfl\n";
    print "    You have to transform it by hand as root\n";
    print "    # hlfl -h for more information\n\n";
    exit;
    }
  }
else {
  print " ** So, you have your HLFL rules at rules.hlfl\n\n";
  }

# EOF
